<html>
<head>
  <meta name="layout" content="_layout2/base-mapping-jpa.html"/>
  <meta name="bread3" content="@Id" href="/docs/mapping/id"/>
<#assign id = "true">
</head>
<body>

<h2 id="id">@Id</h2>
<p>
  Mark a property as the <code>@Id</code> property.
</p>
<pre content="java">
@Entity
public class Contact {

  @Id
  long id;

  ...
}
</pre>

<h2 id="generated-value">@GeneratedValue</h2>
<p>
  When we annotate a property with <code>@Id</code> Ebean will automatically assign an appropriate
  <code>Id generator</code> if the type <code>is a number type or UUID type</code>.
</p>
<p>
  That is, with Ebean it is effectively redundant to also add the <code>@GeneratedValue</code> annotation.
</p>
<pre content="java">
  @Id
  long id;

  // ... is effectively the same as

  @Id @GeneratedValue
  long id;
</pre>

<h2 id="uuid">UUID</h2>
<p>
  If the @Id type is <code>UUID</code> then Ebean will automatically assign an appropriate Id generator
  to that property.
</p>
<pre content="java">
// an appropriate UUID based Id generator
// is automatically assigned
@Id
UUID id;
</pre>

<h2 id="identity">@Identity</h2>
<p>
  Note that Ebean additionally has an <a href="/docs/mapping/identity">@Identity</a> annotation
  when we want to use to specify the <code>starts value</code>, <code>cache value</code> and
  <code>generated by default|always</code> options for database identity or sequence.
</p>
<pre content="java">
  @Id @Identity(start=1000, cache=500)
  long id;
</pre>
<p>
  We can also specify <code>@Identity</code> on the class - typically when the id property
  is inherited from a MappedSuperclass.
</p>
<pre content="java">
@Entity
@Identity(start=1000, cache=500)
public class Contact {

  @Id
  long id;

  ...
}
</pre>

<h2 id="no-lazy-loading">No lazy loading</h2>
<p>
  Note that <code>@Id</code> properties never invoke lazy loading.
</p>

<h2 id="database-platform">Database platform</h2>
<p>
  All the supported databases use either <code>Identity</code> or <code>Sequences</code> (or allow both)
  and Ebean will choose the appropriate Id generation strategy based on the database platform.
</p>
<table class="table">
  <tr><th>Database</th><th>Strategy</th></tr>
  <tr><td>H2</td><td>Identity (also supports sequences)</td></tr>
  <tr><td>Postgres</td><td>Identity (as serial, also supports sequences)</td></tr>
  <tr><td>MySql</td><td>Identity</td></tr>
  <tr><td>Oracle</td><td>Sequences (also supports Identity)</td></tr>
  <tr><td>DB2</td><td>Identity (also supports sequences)</td></tr>
  <tr><td>SQL Server</td><td>Identity</td></tr>
  <tr><td>SQLite</td><td>Identity</td></tr>
  <tr><td>SqlAnywhere</td><td>Identity</td></tr>
</table>

<h2 id="custom">Custom Id Generator</h2>
<p>
  There is support for registering and using a custom Id generator.
</p>

<h4>1. Implement io.ebean.config.IdGenerator</h4>
```java
public class ModUuidGenerator implements IdGenerator {

  @Override
  public Object nextValue() {
    return ModUUID.newShortId();
  }

  @Override
  public String getName() {
    return "shortUid";
  }
}
```
<h4>2. Register with ServerConfig</h4>
<p>
  We register the IdGenerator with ServerConfig by using <code>addClass()</code>
  or <code>add(IdGenerator idGenerator)</code> or <code>setIdGenerators(List<IdGenerator> idGenerators)</code>.
</p>
<p>
  Note that if you are using classpath scanning to find entity beans that this will also automatically
  find implementations of IdGenerator and automatically register them so in this case you don't need to
  register the IdGenerator manually with ServerConfig.
</p>

<h4>3. @GeneratedValue</h4>
<p>
  We can then tell Ebean to use our custom IdGenerator by using the <code>@GeneratedValue</code> with
  the generator being the name of our custom IdGenerator.
</p>
```java
  @Id @GeneratedValue(generator = "shortUid")
  String id;
```


</body>
</html>
