<html>
<head>
  <title>Query Select | Ebean</title>
  <meta name="layout" content="_layout2/base-docs.html"/>
  <meta name="bread1" content="Query" href="/docs/query/"/>
  <meta name="bread2" content="select" href="/docs/query/select"/>
  <#assign n0_docs="true">
  <#assign n1_query="true">
  <#assign select= "true">
</head>
<body>
<h2 id="select">Select</h2>
<p>
  <code>select</code> allows us to control the properties that are fetched at the root level
  of the graph. We can specify to only select some properties to fetch. The result are beans
  that are partially populated.
</p>
<pre content="java">

// "alias" bean that can be used in select and fetch clauses
QCustomer cust = QCustomer.alias();

List<|Customer> customers =
  new QCustomer()
    // only fetch some properties of customer (partial objects)
    .select(cust.name, cust.version, cust.whenCreated)
    .name.istartsWith("Rob")
    .findList();

</pre>
<p>
  With the above we specify the properties we want to fetch. We still get Customer entity beans returned
  but they are <b>partially populated</b>.
</p>
<p>
  The SQL generated by the above query has:
</p>
<pre content="sql">
  select t0.id, t0.name, t0.registered, t0.version from customer t0
</pre>
<p>
  Note that the <code>@Id</code> property is automatically included for most queries and it is
  automatically exludeded for <b>distinct</b>, <b>findSingleAttribute</b> and <b>aggregation</b> queries.
</p>
<p>
  Using query beans to define the select properties provides a type safe way to define what part of the
  object graph to fetch.
</p>

<p>
  The same query written using the query expression API is:
</p>
<pre content="java">
List<|Customer> customers =
  database.find(Customer.class)
    .select("name, registered, version")
    .findList();
</pre>

<h2 id="alias" class="art">alias() - specify properties</h2>
<p>
  Each query bean has a static <code>alias()</code> method that returns a query
  bean that we use to specify properties for fetch in <code>select()</code> and
  <code>fetch()</code>.
</p>
<pre content="java">

// customer "alias"
QCustomer cust = QCustomer.alias();

// contact "alias"
QCustomer con = QContact.alias();

List<|Customer> customers =
  new QCustomer()

    .select(cust.name, cust.version, cust.whenCreated)
    .contacts.fetch(con.firstName, con.LastName, con.email)

    .name.istartsWith("Rob")
    .findList();

</pre>
<p>
  In the above we have alias beans for customer and contact. We use those to specify
  which specific properties we want to fetch.
</p>
<p>
  Note that we can assign <code>alias()</code> to a static final field.
</p>
<pre content="java">
private static final QCustomer CUST = QCustomer.alias();
...
List<|Customer> customers =
  new QCustomer()
    .select(CUST.name)
    .name.istartsWith("Rob")
    .findList();
</pre>

<h2 id="aliasField" class="art">Alias for static imports</h2>
<p>
  As an alternative to the <code>alias()</code> method each query bean also provides
  a static <code>Alias</code> class for the case where we rather use static imports.
</p>
<p>
  For example, we can use <em>QCustomer.Alias</em> to specify properties of customer like the below:
</p>
<pre content="java">

List<|Customer> customers =
  new QCustomer()

    .select(QCustomer.Alias.name, QCustomer.Alias.whenCreated)
    .findList();

</pre>
<p>
  We can then change these to use static imports to get:
</p>
<pre content="java">
import static org.domain.query.QCustomer.Alias.name;
import static org.domain.query.QCustomer.Alias.whenCreated;
...


List<|Customer> customers =
  new QCustomer()

    .select(name, whenCreated) // using static imports of QCustomer.Alias
    .findList();

</pre>
<p>
  The limitation of using Alias like this is that if we do this for multiple query
  bean types (like QCustomer.Alias and QContact.Alias) then we might get a name
  clash. For example, if both had a property called whenCreated we can only static import
  one of them.
</p>
<pre content="java">
import static ...query.QCustomer.Alias.name;
import static ...query.QCustomer.Alias.version;
import static ...query.QCustomer.Alias.whenCreated;
import static ...query.QContact.Alias.firstName;
import static ...query.QContact.Alias.lastName;

// Use explicit QContact.Alias.whenCreated (as clash with QCustomer.Alias.whenCreated)

List<|Customer> customers =
  new QCustomer()
    .select(name, version, whenCreated)
    .contacts.fetch(firstName, lastName, QContact.Alias.whenCreated)

    .name.istartsWith("Rob")
    .findList();

</pre>

<h2 id="formula" cqlass="art">Formula</h2>
<p>
  We need to use this string select clause when we want to specify a formula.
</p>
```java
// java
List<|String> names =
  new QContact()
    .select("concat(lastName,', ',firstName)")
    .lastName.startsWith("A")
    .findSingleAttributeList();
```
```java
// kotlin
var names: List<|String> =
  QContact()
    .select("concat(lastName,' ',firstName)")
    .lastName.startsWith("A")
    .findSingleAttributeList()
```


<h5>Example - Postgis ST_Distance formula</h5>
<p>
  With this example we explicitly cast to a Java BigDecimal type using
  the <code>::BigDecimal</code> cast at the end of the formula.
</p>
```java
// given route is a Postgis geometry(linestring,4326)
// return the distance between the start and end points

BigDecimal routeDistance = query()
  .select("ST_Distance(ST_StartPoint(route), ST_EndPoint(route))::BigDecimal")
  .where()
  .idEq(tripId)
  .findSingleAttribute();
```


<h2 id="asDto" class="art">asDto</h2>
<p>
  When we use a select formula we sometimes want to return the result into a plain <code>DTO bean</code>
  rather than an entity bean. We do this using <code>.asDto(Class&lt;D&gt;)</code> to turn the ORM query
  into a DtoQuery.
</p>
<p>
  For more details refer to <a href="/docs/query/dtoquery">DTO queries</a>.
</p>
```java
// ContactDto is a plain bean with email and fullName properties

List<|ContactDto> contacts =
  new QContact()
    .select("email, concat(lastName, ', ', firstName) as fullName")
    .lastName.startsWith("A")
    .orderBy()
       .lastName.asc()
    .setMaxRows(10)
    .asDto(ContactDto.class)
    .findList();
```


<h2 id="aggregation" class="art">Aggregation</h2>
<p>
  Similar to formula queries we can use the standard aggregations of
  <code>SUM, MAX, MIN, AVG and COUNT</code> in the select clause.
</p>
<p>
  For more details refer to <a href="/docs/query/aggregation">Aggregation queries</a>.
</p>
<h5>Single aggregation queries</h5>
```java
// java
Timestamp maxWhen  =
  new QContact()
    .select("max(whenModified)")
    .findSingleAttribute()
```

```java
// kotlin
var maxWhen: Timestamp =
  QContact()
    .select("max(whenModified)")
    .findSingleAttribute()
```
```sql
select max(t0.when_modified) from contact t0
```


<h5>Group by aggregation queries</h5>
<p>
  When  multiple column aggregation query we use the string select clause.
</p>
```java
List<|MachineStats> result =
  new QMachineStats()
  .select("machine, date, max(rate)")
  .date.gt(LocalDate.now().minusDays(10))
  .query().having().gt("max(rate)", 4)
  .findList();
```
<p>
  The above query produces the following sql:
</p>
```sql
select t0.machine_id, t0.date, max(t0.rate)
from d_machine_stats t0
where t0.date > ?
group by t0.machine_id, t0.date
having max(t0.rate) > ?
```

<@next_edit "Fetch" "/docs/query/fetch" "/docs/query/select.html"/>
</body>
</html>
