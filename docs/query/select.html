<html>
<head>
  <title>Query Select | Ebean</title>
  <meta name="layout" content="_layout2/base-docs.html"/>
  <meta name="bread1" content="Query" href="/docs/query/"/>
  <meta name="bread2" content="select" href="/docs/query/select"/>
  <#assign n0_docs="true">
  <#assign n1_query="true">
  <#assign select= "true">
</head>
<body>
<h2 id="select" about="sum, max, min">Select</h2>
<p>
  <code>select</code> allows us to control the properties that are fetched. We can specify only selected
  properties to fetch.
</p>
```java
List<|Customer> customers =
  query()
    .select("name, registered, version")
    .findList();
```
<p>
  With the above we specify the properties we want to fetch. We still get Customer entity beans returned
  but they are <b>partially populated</b>.
</p>
<p>
  The SQL generated by the above query has:
</p>
```sql
  select t0.id, t0.name, t0.registered, t0.version from customer t0
```
<p>
  Note that the <code>@Id</code> property is automatically included for most queries and it is
  automatically exludeded for <b>distinct</b>, <b>findSingleAttribute</b> and <b>aggregation</b> queries.
</p>


<h4>Query beans</h4>
<p>
  Query beans provide a type safe way to define what part of the object graph to fetch in
  addition to the approaches provided via the normal Query.
</p>
<p>
  Each query bean provides an <em>alias</em> bean that can be used in <em>select</em> and <em>fetch</em>.
</p>
<p>
  In the example below we specify which properties to include in the select and only these
  properties are loaded into the entity beans. This is described as "partial object".
</p>
```java

// "alias" bean that can be used in select and fetch clauses
QCustomer cust = QCustomer.alias();

List<|Customer> customers =
  new QCustomer()
  // only fetch some properties of customer (partial objects)
  .select(cust.name, cust.version, cust.whenCreated)
  .name.istartsWith("Rob")
  .findList();

```
<p>
  The above query produces the following sql:
</p>
```sql
select t0.id, t0.name, t0.version, t0.when_created
from customer t0
where lower(t0.name) like ? escape'|'; --bind(rob%)
```

<h2 id="formula" class="art">Formula</h2>
<p>
  We need to use this string select clause when we want to specify a formula.
</p>
```java
// java
List<|String> names =
  new QContact()
    .select("concat(lastName,', ',firstName)")
    .lastName.startsWith("A")
    .findSingleAttributeList();
```
```java
// kotlin
var names: List<|String> =
  QContact()
    .select("concat(lastName,' ',firstName)")
    .lastName.startsWith("A")
    .findSingleAttributeList()
```


<h5>Example - Postgis ST_Distance formula</h5>
<p>
  With this example we explicitly cast to a Java BigDecimal type using
  the <code>::BigDecimal</code> cast at the end of the formula.
</p>
```java
// given route is a Postgis geometry(linestring,4326)
// return the distance between the start and end points

BigDecimal routeDistance = query()
  .select("ST_Distance(ST_StartPoint(route), ST_EndPoint(route))::BigDecimal")
  .where()
  .idEq(tripId)
  .findSingleAttribute();
```


<h2 id="asDto" class="art">asDto</h2>
<p>
  When we use a select formula we sometimes want to return the result into a plain <code>DTO bean</code>
  rather than an entity bean. We do this using <code>.asDto(Class&lt;D&gt;)</code> to turn the ORM query
  into a DtoQuery.
</p>
<p>
  For more details refer to <a href="/docs/query/dto">DTO queries</a>.
</p>
```java
// ContactDto is a plain bean with email and fullName properties

List<|ContactDto> contacts =
  new QContact()
    .select("email, concat(lastName, ', ', firstName) as fullName")
    .lastName.startsWith("A")
    .orderBy()
       .lastName.asc()
    .setMaxRows(10)
    .asDto(ContactDto.class)
    .findList();
```


<h2 id="aggregation" class="art">Aggregation</h2>
<p>
  Similar to formula queries we can use the standard aggregations of
  <code>SUM, MAX, MIN, AVG and COUNT</code> in the select clause.
</p>
<p>
  For more details refer to <a href="/docs/query/aggregation">Aggregation queries</a>.
</p>
<h5>Single aggregation queries</h5>
```java
// java
Timestamp maxWhen  =
  new QContact()
    .select("max(whenModified)")
    .findSingleAttribute()
```

```java
// kotlin
var maxWhen: Timestamp =
  QContact()
    .select("max(whenModified)")
    .findSingleAttribute()
```
```sql
select max(t0.when_modified) from contact t0
```


<h5>Group by aggregation queries</h5>
<p>
  When  multiple column aggregation query we use the string select clause.
</p>
```java
List<|MachineStats> result =
  new QMachineStats()
  .select("machine, date, max(rate)")
  .date.gt(LocalDate.now().minusDays(10))
  .query().having().gt("max(rate)", 4)
  .findList();
```
<p>
  The above query produces the following sql:
</p>
```sql
select t0.machine_id, t0.date, max(t0.rate)
from d_machine_stats t0
where t0.date > ?
group by t0.machine_id, t0.date
having max(t0.rate) > ?
```

<@next_edit "Fetch" "/docs/query/fetch" "/docs/query/select"/>
</body>
</html>
